// Generated by CoffeeScript 1.6.2
(function() {
  var Scene, Tile, TileGroup, Vec2, Vec3;

  Vec2 = (function() {
    function Vec2(x, y) {
      this.x = x;
      this.y = y;
    }

    Vec2.prototype.to = function(b) {
      return new Vec3(b.x - this.x, b.y - this.y);
    };

    return Vec2;

  })();

  Vec3 = (function() {
    function Vec3(x, y, z) {
      this.x = x;
      this.y = y;
      this.z = z;
    }

    Vec3.prototype.to = function(b) {
      return new Vec3(b.x - this.x, b.y - this.y, b.z - this.z);
    };

    Vec3.prototype.dot = function(b) {
      return this.x * b.x + this.y * b.y + this.z * b.z;
    };

    Vec3.prototype.cross = function(b) {
      return new Vec3(this.y * b.z - this.y * b.x, this.z * b.x - this.x * b.z, this.x * b.y - this.y * b.x);
    };

    Vec3.prototype.move = function(x, y, z) {
      this.x += x;
      this.y += y;
      return this.z += z;
    };

    Vec3.prototype.roty = function(a) {
      var cosa, sina;

      cosa = Math.cos(a);
      sina = Math.sin(a);
      return new Vec3(cosa * this.x - sina * this.z, this.y, sina * this.x + cosa * this.z);
    };

    Vec3.prototype.rotx = function(a) {
      var cosa, sina;

      cosa = Math.cos(a);
      sina = Math.sin(a);
      return new Vec3(this.x, cosa * this.y - sina * this.z, sina * this.y + cosa * this.z);
    };

    Vec3.prototype.rotz = function(a) {
      var cosa, sina;

      cosa = Math.cos(a);
      sina = Math.sin(a);
      return new Vec3(cosa * this.x - sina * this.y, sina * this.x + cosa * this.y, this.z);
    };

    Vec3.prototype.distance = function(v) {
      var dx, dy, dz;

      dx = this.x - v.x;
      dy = this.y - v.y;
      dz = this.z - v.z;
      return Math.sqrt(dx * dx + dy * dy + dz * dz);
    };

    Vec3.prototype.reverse = function() {
      return new Vec3(-this.x, -this.y, -this.z);
    };

    Vec3.prototype.add = function(v) {
      return new Vec3(this.x + v.x, this.y + v.y, this.z + v.z);
    };

    return Vec3;

  })();

  Tile = (function() {
    function Tile(y) {
      this.y = y;
      this.size = 0;
    }

    Tile.prototype.points = function() {
      return [new Vec3(this.size, this.y, this.size), new Vec3(-this.size, this.y, this.size), new Vec3(-this.size, this.y, -this.size), new Vec3(this.size, this.y, -this.size)];
    };

    return Tile;

  })();

  TileGroup = (function() {
    function TileGroup(count, startz, endz) {
      var i, _i;

      this.tiles = [];
      for (i = _i = 0; 0 <= count ? _i < count : _i > count; i = 0 <= count ? ++_i : --_i) {
        this.tiles.push(new Tile(startz + (endz - startz) / count * i));
      }
    }

    TileGroup.prototype.wave = function(x, a, w, b) {
      a = a || 50;
      w = w || Math.PI * (2 - Math.cos(x / 4));
      b = b || 10;
      return this.match(function(i, len) {
        var dx, p, theta;

        theta = 1 - i / len;
        dx = theta + x - 2;
        if (dx < -1) {
          p = 0;
        } else if (dx < 0) {
          p = -dx * dx + 1;
        } else {
          p = 1;
        }
        return (a + b + a * Math.sin(w * theta + x)) * p;
      });
    };

    TileGroup.prototype.audio = function(audio, data) {
      var i, ind, len, time, _i, _ref, _results;

      time = Math.round(audio.currentTime * 20);
      len = this.tiles.length;
      _results = [];
      for (i = _i = 0, _ref = this.tiles.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        if ((ind = time * 5 + i) > data.length) {
          _results.push(this.tiles[len - i - 1].size = 0);
        } else {
          _results.push(this.tiles[len - i - 1].size = data[ind]);
        }
      }
      return _results;
    };

    TileGroup.prototype.match = function(f) {
      var i, len, _i, _results;

      len = this.tiles.length;
      _results = [];
      for (i = _i = 0; 0 <= len ? _i < len : _i > len; i = 0 <= len ? ++_i : --_i) {
        _results.push(this.tiles[i].size = f(i, len));
      }
      return _results;
    };

    return TileGroup;

  })();

  Scene = (function() {
    function Scene(id) {
      this.canvas = document.getElementById(id);
      if (this.canvas.getContext) {
        this.ctx = this.canvas.getContext("2d");
        this.w = this.canvas.width / 2;
        this.h = this.canvas.height / 2;
        this.zvec = new Vec3(0, 0, 1000);
        this.rotx = 0;
        this.roty = 0;
        this.rotz = 0;
        this.ctx.translate(this.w, this.h);
        this.ctx.globalAlpha = 0.95;
        this.color = "#69F";
      } else {
        throw new Error("Can not get 2d context, browser do not support html5 canvas");
      }
    }

    Scene.prototype.createTileGroup = function(count, az, bz) {
      return this.tilegroup = new TileGroup(count, az, bz);
    };

    Scene.prototype.proj = function(tile) {
      var delta, list, px, py, roted, vec, _i, _len, _ref;

      list = [];
      _ref = tile.points();
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        vec = _ref[_i];
        roted = vec.roty(this.roty).rotx(this.rotx);
        delta = roted.distance(this.zvec);
        px = roted.x * delta / this.zvec.z;
        py = roted.y * delta / this.zvec.z;
        list.push(new Vec2(px, py));
      }
      return list;
    };

    Scene.prototype.requestFrame = (function() {
      var func;

      func = (function() {
        return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function(callback) {
          return setTimeout(callback, 1000 / 60);
        };
      })();
      return function(callback) {
        return func.call(window, callback);
      };
    })();

    Scene.prototype.render = function() {
      var i, p, projs, tile, _i, _j, _len, _ref, _ref1, _results;

      this.ctx.clearRect(-this.w, -this.h, this.w * 2, this.h * 2);
      _results = [];
      for (i = _i = 0, _ref = this.tilegroup.tiles.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        tile = this.tilegroup.tiles[i];
        if (projs = this.proj(tile)) {
          this.ctx.beginPath();
          this.ctx.fillStyle = this.color;
          this.ctx.moveTo(projs[0].x, projs[0].y);
          _ref1 = projs.slice(1);
          for (_j = 0, _len = _ref1.length; _j < _len; _j++) {
            p = _ref1[_j];
            this.ctx.lineTo(p.x, p.y);
          }
          this.ctx.closePath();
          this.ctx.fill();
          this.ctx.strokeStyle = "#FFF";
          this.ctx.lineWidth = 3;
          _results.push(this.ctx.stroke());
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    Scene.prototype.enterFrame = function(func) {
      if (typeof func === 'function') {
        return this.enterframe = func;
      } else {
        throw new TypeError("augument 'func' should be a function");
      }
    };

    Scene.prototype.animate = function() {
      var ts;

      if (typeof this.enterframe === 'function') {
        ts = this;
        return this.requestFrame(function() {
          ts.enterframe();
          ts.render();
          return ts.animate();
        });
      }
    };

    return Scene;

  })();

  (function() {
    var audio, cdiv, detail, focuswave, link, links, playimage, read, scene, swif, _i, _len;

    read = document.getElementById("read");
    playimage = document.getElementById("playimage");
    audio = document.getElementById("audio");
    links = document.querySelectorAll("#links a");
    detail = document.getElementById("detail");
    focuswave = null;
    cdiv = null;
    swif = function() {
      scene.color = "#69f";
      scene.roty = 0;
      return playimage.src = "images/play.svg";
    };
    audio.addEventListener("ended", swif);
    audio.addEventListener("emptied", swif);
    audio.addEventListener("play", function() {
      return playimage.src = "images/playing.svg";
    });
    read.onclick = function() {
      if (audio.paused) {
        audio.currentTime = 0;
        scene.color = "#ff8000";
        if (audio.readyState >= 4) {
          return audio.play();
        } else {
          playimage.src = "images/wait.svg";
          return audio.autoplay = "autoplay";
        }
      }
    };
    audio.addEventListener("ended", function() {});
    for (_i = 0, _len = links.length; _i < _len; _i++) {
      link = links[_i];
      link.onclick = function() {
        var showdiv, _j, _len1;

        cdiv = document.querySelector(this.dataset["selector"]);
        if (!cdiv.classList.contains("focus")) {
          for (_j = 0, _len1 = links.length; _j < _len1; _j++) {
            link = links[_j];
            link.classList.remove("focus");
          }
          this.classList.add("focus");
          audio.autoplay = "";
          audio.src = "";
          audio.src = "audio/" + this.dataset['media'] + ".mp3";
          focuswave = WAVEDATA[this.dataset['media']];
          showdiv = function() {
            var div, _k, _len2, _ref;

            _ref = document.querySelectorAll("#detail div");
            for (_k = 0, _len2 = _ref.length; _k < _len2; _k++) {
              div = _ref[_k];
              div.classList.remove("focus");
            }
            cdiv.classList.add("focus");
            return detail.classList.add("show");
          };
          if (detail.classList.contains("show")) {
            detail.classList.remove("show");
            return setTimeout(showdiv, 500);
          } else {
            return showdiv.call();
          }
        }
      };
    }
    scene = new Scene("scene");
    scene.createTileGroup(5, 60, -60);
    scene.rotx = 0.25;
    scene.enterFrame(function() {
      this.roty += (Math.PI / 128) % (Math.PI * 16);
      if (audio.paused) {
        return scene.tilegroup.wave(this.roty);
      } else {
        return scene.tilegroup.audio(audio, focuswave);
      }
    });
    return scene.animate();
  })();

}).call(this);

/*
//@ sourceMappingURL=scene.map
*/
