// Generated by CoffeeScript 1.6.2
(function() {
  var Scene, Shape, Style, Vec3;

  Vec3 = (function() {
    function Vec3(x, y, z) {
      this.x = x;
      this.y = y;
      this.z = z;
    }

    Vec3.prototype.dot = function(b) {
      return this.x * b.x + this.y * b.y + this.z * b.z;
    };

    Vec3.prototype.cross = function(b) {
      return Vec3(this.y * b.z - this.y * b.x, this.z * b.x - this.x * b.z, this.x * b.y - this.y * b.x);
    };

    Vec3.prototype.move = function(x, y, z) {
      this.x += x;
      this.y += y;
      return this.z += z;
    };

    Vec3.prototype.rot = function(a, b) {
      var cosa, cosb, sina, sinb, xsza;

      cosa = Math.cos(a);
      sina = Math.sin(a);
      cosb = Math.cos(b);
      sinb = Math.sin(b);
      xsza = this.x * sina + this.z * cosa;
      return Vec3(this.x * cosa - this.z * sina, this.y * cosb - sinb * xsza, this.y * sinb + cosb * xsza);
    };

    return Vec3;

  })();

  Style = (function() {
    function Style() {}

    Style.fillStyle = "#fff";

    Style.strokeStyle = "#000";

    Style.lineWidth = "";

    Style.lineCap = "";

    Style.lineJoin = "";

    Style.prototype._pstyle = function(r, g, b, a) {
      if (typeof r === "String" && r.match(/#[0-9a-fA-F]{3}|#[0-9a-fA-F]{6}/)) {
        return r;
      } else if (typeof r === "number" && !a) {
        return "rgb(" + r + "," + g + "," + b + ")";
      } else {
        return "rgba(" + r + "," + g + "," + b + "," + a + ")";
      }
    };

    Style.prototype.fillStyle = function(r, g, b, a) {
      return this.fillStyle = this._pstyle(r, g, b, a);
    };

    Style.strokeStyle = function(r, g, b, a) {
      return this.strokeStyle = this._pstyle(r, g, b, a);
    };

    return Style;

  })();

  Shape = (function() {
    function Shape(points) {
      var v1, v2;

      if (points && points.length >= 3) {
        v1 = new Vec3(points[0], points[1]);
        v2 = new Vec3(points[0], points[2]);
        this.points = points;
        this.norm = v1.cross(v2);
      } else {
        throw new TypeError("argument points must be a list with more than 3 points");
      }
    }

    Shape.prototype.at = function(pos) {
      return this.points[pos];
    };

    Shape.prototype.first = function() {
      if (this.points.length) {
        return this.points[0];
      } else {
        return null;
      }
    };

    Shape.prototype.last = function() {
      if (this.points.length) {
        return this.points[this.points.length - 1];
      } else {
        return null;
      }
    };

    Shape.prototype.iterator = function() {
      var cur;

      cur = 0;
      return function() {
        var point;

        if (cur < this.points.length) {
          point = this.points[cur];
          cur += 1;
          return points;
        } else {
          return null;
        }
      };
    };

    Shape.prototype.riterator = function() {
      var cur;

      cur = this.points.length - 1;
      return function() {
        var point;

        if (cur > 0) {
          point = this.point[cur];
          cur -= 1;
          return point;
        } else {
          return null;
        }
      };
    };

    Shape.prototype.style = function(style) {
      if (style instanceof Style) {
        return this.style = style;
      } else {
        throw TypeError("argument 'style' must be an instance of Style");
      }
    };

    return Shape;

  })();

  Scene = (function() {
    function Scene(id) {
      this.canvas = document.getElementById(id);
      if (this.canvas.getContext) {
        this.ctx = getContext("2d");
        this.zvec = new Vec3(0, 0, 1);
        this.tvec = new Vec3(0, 0, 0);
        this.shapes = [];
        this.rota = 0;
        this.rotb = 0;
      } else {
        throw new Error("Can not get 2d context, browser do not support html5 canvas");
      }
    }

    Scene.prototype.addShape = function(shape) {
      if (shape instanceof Shape) {
        return this.shapes.push(shape);
      } else {
        throw new TypeError("argument 'shape' must be an instance of Shape");
      }
    };

    Scene.prototype.render = function() {
      var shape, _i, _len, _ref, _results;

      _ref = this.shapes;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        shape = _ref[_i];
        if (shape.norm.dot(this.zvec) > 0) {
          _results.push(shape.draw(this.ctx));
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    return Scene;

  })();

}).call(this);

/*
//@ sourceMappingURL=scene.map
*/
