// Generated by CoffeeScript 1.6.2
(function() {
  var Scene, Shape, Style, Vec2, Vec3;

  Vec2 = (function() {
    function Vec2(x, y) {
      this.x = x;
      this.y = y;
    }

    return Vec2;

  })();

  Vec3 = (function() {
    function Vec3(x, y, z) {
      this.x = x;
      this.y = y;
      this.z = z;
    }

    Vec3.prototype.to = function(b) {
      return new Vec3(b.x - this.x, b.y - this.y, b.z - this.z);
    };

    Vec3.prototype.dot = function(b) {
      return this.x * b.x + this.y * b.y + this.z * b.z;
    };

    Vec3.prototype.cross = function(b) {
      return new Vec3(this.y * b.z - this.y * b.x, this.z * b.x - this.x * b.z, this.x * b.y - this.y * b.x);
    };

    Vec3.prototype.move = function(x, y, z) {
      this.x += x;
      this.y += y;
      return this.z += z;
    };

    Vec3.prototype.rot = function(a, b) {
      var cosa, cosb, sina, sinb, xsza;

      cosa = Math.cos(a);
      sina = Math.sin(a);
      cosb = Math.cos(b);
      sinb = Math.sin(b);
      xsza = this.x * sina + this.z * cosa;
      return new Vec3(this.x * cosa - this.z * sina, this.y * cosb - sinb * xsza, this.y * sinb + cosb * xsza);
    };

    Vec3.prototype.distance = function(v) {
      var dx, dy, dz;

      dx = this.x - v.x;
      dy = this.y - v.y;
      dz = this.z - v.z;
      return Math.sqrt(dx * dx + dy * dy + dz * dz);
    };

    return Vec3;

  })();

  Style = (function() {
    function Style() {}

    Style.fillStyle = "#fff";

    Style.strokeStyle = "#000";

    Style.lineWidth = "";

    Style.lineCap = "";

    Style.lineJoin = "";

    Style.prototype._pstyle = function(r, g, b, a) {
      if (typeof r === "String" && r.match(/#[0-9a-fA-F]{3}|#[0-9a-fA-F]{6}/)) {
        return r;
      } else if (typeof r === "number" && !a) {
        return "rgb(" + r + "," + g + "," + b + ")";
      } else {
        return "rgba(" + r + "," + g + "," + b + "," + a + ")";
      }
    };

    Style.prototype.fillStyle = function(r, g, b, a) {
      return this.fillStyle = this._pstyle(r, g, b, a);
    };

    Style.strokeStyle = function(r, g, b, a) {
      return this.strokeStyle = this._pstyle(r, g, b, a);
    };

    return Style;

  })();

  Shape = (function() {
    function Shape(points) {
      var v1, v2;

      if (points && points.length >= 3) {
        v1 = points[0].to(points[1]);
        v2 = points[0].to(points[2]);
        this.points = points;
        this.norm = v1.cross(v2);
      } else {
        throw new TypeError("argument points must be a list with more than 3 points");
      }
    }

    Shape.prototype.at = function(pos) {
      return this.points[pos];
    };

    Shape.prototype.first = function() {
      if (this.points.length) {
        return this.points[0];
      } else {
        return null;
      }
    };

    Shape.prototype.last = function() {
      if (this.points.length) {
        return this.points[this.points.length - 1];
      } else {
        return null;
      }
    };

    Shape.prototype.iterator = function() {
      var cur, points;

      cur = 0;
      points = this.points;
      return function() {
        var point;

        if (cur < points.length) {
          point = points[cur];
          cur += 1;
          return point;
        } else {
          return null;
        }
      };
    };

    Shape.prototype.riterator = function() {
      var cur, points;

      cur = this.points.length - 1;
      points = this.points;
      return function() {
        var point;

        if (cur > 0) {
          point = points[cur];
          curi -= 1;
          return point;
        } else {
          return null;
        }
      };
    };

    Shape.prototype.style = function(style) {
      if (style instanceof Style) {
        return this.style = style;
      } else {
        throw TypeError("argument 'style' must be an instance of Style");
      }
    };

    return Shape;

  })();

  Scene = (function() {
    function Scene(id) {
      this.canvas = document.getElementById(id);
      if (this.canvas.getContext) {
        this.ctx = this.canvas.getContext("2d");
        this.w = this.canvas.width / 2;
        this.h = this.canvas.height / 2;
        this.zvec = new Vec3(0, 0, 1000);
        this.tvec = new Vec3(0, 0, 0);
        this.shapes = [];
        this.rota = 0;
        this.rotb = 0;
        this.ctx.translate(this.w, this.h);
      } else {
        throw new Error("Can not get 2d context, browser do not support html5 canvas");
      }
    }

    Scene.prototype.addShape = function(shape) {
      if (shape instanceof Shape) {
        return this.shapes.push(shape);
      } else {
        throw new TypeError("argument 'shape' must be an instance of Shape");
      }
    };

    Scene.prototype.proj = function(vec) {
      var delta, px, py, rotated;

      if (vec) {
        rotated = vec.rot(this.rota, this.rotb);
        delta = rotated.distance(this.zvec);
        px = rotated.x * delta / this.zvec.z;
        py = rotated.y * delta / this.zvec.z;
        return new Vec2(px, py);
      } else {
        return null;
      }
    };

    Scene.prototype.requestFrame = (function() {
      var func;

      func = (function() {
        return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function(callback) {
          return setTimeout(callback, 1000 / 60);
        };
      })();
      return function(callback) {
        return func.call(window, callback);
      };
    })();

    Scene.prototype.render = function() {
      var iter, point, shape, _i, _len, _ref, _results;

      this.ctx.clearRect(-this.w, -this.h, this.w * 2, this.h * 2);
      _ref = this.shapes;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        shape = _ref[_i];
        if (shape.norm.rot(this.rota, -this.rotb).dot(this.zvec) > 0) {
          iter = shape.iterator();
          point = this.proj(iter());
          this.ctx.beginPath();
          this.ctx.moveTo(point.x, point.y);
          while (point = this.proj(iter())) {
            this.ctx.lineTo(point.x, point.y);
          }
          this.ctx.closePath();
          _results.push(this.ctx.stroke());
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    Scene.prototype.enterFrame = function(func) {
      if (typeof func === 'function') {
        return this.enterframe = func;
      } else {
        throw new TypeError("augument 'func' should be a function");
      }
    };

    Scene.prototype.animate = function() {
      var ts;

      if (typeof this.enterframe === 'function') {
        ts = this;
        return this.requestFrame(function() {
          ts.enterframe();
          ts.render();
          if (ts.shapes) {
            return ts.animate();
          }
        });
      }
    };

    Scene.prototype.load = function(url, scale) {
      var data, group, line, num, shapes, vec, vecs, xhr, _i, _len, _ref;

      xhr = new XMLHttpRequest();
      xhr.open('GET', url, false);
      xhr.send(null);
      if (xhr.status === 200) {
        data = xhr.responseText;
      } else {
        throw new Error("get obj data failed, status: " + xhr.status);
      }
      scale = scale || 1;
      vecs = [];
      shapes = [];
      _ref = data.split('\n');
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        line = _ref[_i];
        if (line[0] === 'v') {
          group = line.split(' ');
          vec = new Vec3(scale * parseFloat(group[1]), scale * parseFloat(group[2]), scale * parseFloat(group[3]));
          vecs.push(vec);
        } else if (line[0] === 'f') {
          group = line.split(' ');
          shapes.push(new Shape((function() {
            var _j, _len1, _ref1, _results;

            _ref1 = group.slice(1);
            _results = [];
            for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
              num = _ref1[_j];
              _results.push(vecs[parseInt(num) - 1]);
            }
            return _results;
          })()));
        }
      }
      return this.shapes = this.shapes.concat(shapes);
    };

    return Scene;

  })();

  (function() {
    var a, scene;

    scene = new Scene("scene");
    scene.load("javascripts/logo.obj", 100);
    a = 0;
    scene.enterFrame(function() {
      a += Math.PI / 90;
      return this.rota = Math.PI + Math.PI * Math.sin(a) / 4;
    });
    return scene.animate();
  })();

}).call(this);

/*
//@ sourceMappingURL=scene.map
*/
